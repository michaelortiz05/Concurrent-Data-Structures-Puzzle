PROBLEM 1
My approach to this problem was to employ optimistic synchronization in order to create an ordered linked list that supports efficient concurrent access. There are 4 servants who each have their own class with references to a shared linked list and bag that is implmented as a form of concurrent set with random O(1) access. The linked list supports the add, remove, and contains operations. Until the bag is empty, each servant will attempt to remove a present from the bag and then place it in the linked list and then immediately write a thank you note. This is recorded as two seperate member variables respectively. By the end of execution, the total tallies for all threads are reported in a text file. Since this approach uses optimistic synchronization, deadlock is avoided. Further, testing on my machine yielding suprising efficient results: All 500k presents were handled in under one second.

PROBLEM 2
In this problem I decided to make use of a lock-based deque based on the implementation from the C++ STL. Every simulated minute that each of the 8 threads run pushs a new temperature reading to the back of the deque in O(1) time. Each temperature reading is represented as a struct carrying two ints representing temperature and minute. At the end of each simulated hour, the main thread pops the deque and places each element into a minheap and a maxheap. Also, every element marking the start/end is placed into a hashmap such that the smallest value is contained at the start of the interval and the largest at the end. Now with all the data sorted it is just a matter of popping 5 elements from each heap to find the largest/smallest temperatures, and using a sliding window across 6 keys in the hash table to find the largest difference. These are essentially O(1) operations. In this simulation, 600 Milliseconds represents an hour and 10 milliseconds represents a minute.

TO RUN
Compile on a unix command line with: g++ ConcurrentDataStructures.cpp main.cpp Servant.cpp -pthread
Execute with: ./a.out
